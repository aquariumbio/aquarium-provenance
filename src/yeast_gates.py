import logging
from aquarium.trace_factory import (
    file_generator_patch,
    infer_collection_source_from_parts,
    infer_part_source_from_collection,
    tag_measurement_operations)


def add_yg_op_attributes(trace):
    """
    only add measurement operation attribute to operations that only do the
    measurement.
    """
    instruments_url = 'agave://data-sd2e-community/biofab/instruments'
    accuri_path = 'accuri/5539/11272017/cytometer_configuration.json'
    synergy_path = 'synergy_ht/216503/03132018/platereader_configuration.json'
    accuri_url = "{}/{}".format(instruments_url, accuri_path)
    synergy_url = "{}/{}".format(instruments_url, synergy_path)
    tag_measurement_operations(
        trace,
        {
            'Flow Cytometry 96 well': {
                'measurement_type': 'FLOW',
                'instrument_configuration': accuri_url
            },
            '4. Measure OD and GFP': {
                'measurement_type': 'PLATE_READER',
                'instrument_configuration': synergy_url
            },
            '3. Synchronize by OD': {
                'measurement_type': 'PLATE_READER',
                'instrument_configuration': synergy_url
            },
            'Cytometer Bead Calibration': {
                'measurement_type': 'FLOW',
                'instrument_configuration': accuri_url
            }
        }
    )


def fix_plate_reader_file_sources(file_entity):
    """
    Fixes a misinterpretation issue with plate reader files in yeast gates
    where a file may be associated with multiple items to make computations
    easier.

    The correct source ID is usually the first in the list, but file names have
    the ID, so checking just to be certain.
    """
    for source in file_entity.sources:
        if source.item_id in file_entity.name:
            msg = "Replacing sources for file %s with %s %s"
            logging.info(msg, file_entity.file_id,
                         source.item_type, source.item_id)
            file_entity.sources = [source]
            return


def fix_plate_reader_file_generators(file_entity, trace):
    """
    YG plate reader files generated in three places:
    - IGEM protocol plate created by Resuspension and Outgrowth
    - Initial OD in Synch by OD
    - Final reading in Measure OD & GFP
    """
    if file_entity.generator:
        return
    if not file_entity.sources:
        return
    if len(file_entity.sources) > 1:
        return

    source = next(iter(file_entity.sources))
    if source.generator.is_job():
        return
    source_gen = source.generator
    op_list = trace.get_operations(source.item_id)
    if source_gen.operation_type.name == "2. Resuspension and Outgrowth":
        if not op_list:  # IGEM protocol
            file_entity.add_generator(source_gen)
            source.add_attribute({'standard': 'IGEM_protocol'})


def fix_bead_files(trace, plan):
    """
    The protocol doesn't link the calibration beads to either the operation or
    item, so end up as stray uploads.
    """
    bead_ops = ['Flow Cytometry 96 well', 'Cytometer Bead Calibration']
    bead_uploads = [up.id for up in [
        assoc.upload for assoc in plan.data_associations
        if assoc.upload and 'BEAD' in assoc.key]]
    if not bead_uploads:
        logging.warning("No bead associations found")
        return

    flow_ops = [op for _, op in trace.operations.items()
                if op.operation_type.name in bead_ops]
    if not flow_ops:
        logging.warning("No cytometry operations found")
        return

    bead_inputs = list()
    for inputs in [op.inputs for op in flow_ops]:
        for arg in inputs:
            if arg.name == 'calibration beads':
                bead_inputs.append(arg.item_id)
    if not bead_inputs:
        logging.warning(
            "No calibration beads as inputs to cytometry operation")
        return

    # TODO: check that there are enough beads for inputs
    for i in range(len(bead_inputs)):
        file_entity = trace.get_file(bead_uploads[i])
        file_entity.add_generator(flow_ops[i])
        bead_item = trace.get_item(bead_inputs[i])
        file_entity.add_source(bead_item)
        bead_item.add_attribute({'standard': 'BEAD_FLUORESCENCE'})
        logging.info("Adding beads %s as source for file %s",
                     bead_item.item_id, file_entity.file_id)


def fix_part_sources(trace, entity):
    """
    Heuristic to add sources for parts of a collection generated by an operator
    that copies a collection well-to-well.
    """
    pass_through_ops = ['4. Measure OD and GFP']
    if entity.sources:
        return
    if not entity.is_part():
        return
    coll_entity = entity.collection
    if not coll_entity.generator:
        return
    if coll_entity.generator.operation_type.name in pass_through_ops:
        infer_part_source_from_collection(trace, entity)


def fix_sources(trace):
    for _, entity in trace.items.items():
        if entity.sources:
            continue

        if entity.is_part():
            fix_part_sources(trace, entity)
        elif entity.is_collection():
            infer_collection_source_from_parts(trace, entity)


def patch_trace(trace, plan):
    trace.add_attribute({'challenge_problem': 'YEAST_GATES'})
    add_yg_op_attributes(trace)

    fix_sources(trace)
    fix_bead_files(trace, plan)
    for _, entity in trace.files.items():
        if len(entity.sources) > 1:
            fix_plate_reader_file_sources(entity)
    file_generator_patch(trace)
    for _, entity in trace.files.items():
        if not entity.generator:
            fix_plate_reader_file_generators(entity, trace)


def get_upload_attributes(attr_object):
    return {key: value for key, value in attr_object['attributes'].items()
            if is_upload(value)}


def is_upload(attribute_object):
    upload_keys = set([
        'created_at', 'id', 'job_id', 'updated_at', 'upload_content_type',
        'upload_file_name', 'upload_file_size', 'upload_updated_at'
    ])
    return attribute_object.keys() == upload_keys


def add_plan_upload_attributes(trace):
    """
    Look for otherwise orphaned uploads
    """
    uploads = get_upload_attributes(trace)
    for _, upload in uploads.items():
        if not trace.has_file(upload.id):
            pass  # should add to trace


def fix_resuspension_outgrowth_output(trace, coll_entity):
    # TODO: also should check if any parts are missing sources
    if coll_entity.sources:
        return
    if not coll_entity.generator:  # wont work if no generator
        return
    generator = coll_entity.generator
    if generator.operation_type.name != '2. Resuspension and Outgrowth':
        plates = [arg for arg in generator.inputs if arg.name == 'Yeast Plate']
        
        
        # get replicates
        param = next(iter([arg for arg in generator.inputs
                           if arg.name == 'Biological Replicates']))
        replicates = param.value

        pass
